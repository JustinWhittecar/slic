package main

// ─── Movement ───────────────────────────────────────────────────────────────
// BT movement: flood-fill reachable hexes with terrain MP costs.

type MoveMode int

const (
	ModeStand MoveMode = iota
	ModeWalk
	ModeRun
	ModeJump
)

// ReachableHex represents a hex a mech can move to with a given move mode.
type ReachableHex struct {
	Coord   HexCoord
	Facing  int      // 0-5, final facing
	Mode    MoveMode
	MPSpent int
	HexesMoved int   // for TMM calculation
	MoveHeat   int   // heat generated by this movement
}

// MovementCost returns the MP cost to enter a hex from an adjacent hex.
// Returns -1 if the hex is impassable.
func MovementCost(board *Board, from, to HexCoord, mode MoveMode) int {
	hex := board.Get(to)
	if hex == nil {
		return -1
	}
	fromHex := board.Get(from)
	if fromHex == nil {
		return -1
	}

	cost := 1 // base cost

	// Elevation change
	elevDiff := hex.Elevation - fromHex.Elevation
	if elevDiff > 0 {
		cost += elevDiff // +1 per level up
	}
	// Going down is free (cost 0 extra) but still 1 base

	// Terrain costs
	if hasWoods, level := hex.HasTerrain(TerrainWoods); hasWoods {
		cost += level // light +1, heavy +2
	}
	if hasWater, depth := hex.HasTerrain(TerrainWater); hasWater {
		if depth >= 1 {
			cost += depth // depth 1 = +1, depth 2 = +2, etc.
		}
	}
	if hasRough, _ := hex.HasTerrain(TerrainRough); hasRough {
		cost += 1
	}
	if hasSand, _ := hex.HasTerrain(TerrainSand); hasSand {
		cost += 1
	}

	// Road reduces cost (but minimum 1)
	if hasRoad, _ := hex.HasTerrain(TerrainRoad); hasRoad {
		if cost > 1 {
			cost = 1 // road negates terrain cost
		}
	}

	// Elevation change > 2 levels is impassable for ground movement
	if mode != ModeJump && absInt(elevDiff) > 2 {
		return -1
	}

	return cost
}

func absInt(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// FacingChangeCost returns the MP cost to change facing.
// In BT, each hexside turn costs 1 MP for walking/running.
// Jumping can change facing freely on landing.
func FacingChangeCost(fromFacing, toFacing int) int {
	diff := ((toFacing - fromFacing) % 6 + 6) % 6
	if diff > 3 {
		diff = 6 - diff
	}
	return diff
}

// ReachableHexes computes all hexes a mech can reach from a starting position.
// For Walk/Run: flood-fill with terrain costs.
// For Jump: all hexes within jumpMP hex distance.
func ReachableHexes(board *Board, start HexCoord, facing int,
	walkMP, runMP, jumpMP int, mode MoveMode) []ReachableHex {

	var results []ReachableHex

	// Standing still is always an option
	if mode == ModeStand {
		results = append(results, ReachableHex{
			Coord: start, Facing: facing, Mode: ModeStand,
			MPSpent: 0, HexesMoved: 0, MoveHeat: 0,
		})
		return results
	}

	if mode == ModeJump && jumpMP > 0 {
		return reachableJump(board, start, facing, jumpMP)
	}

	mp := walkMP
	heat := 1 // walking heat
	if mode == ModeRun {
		mp = runMP
		heat = 2
	}

	if mp <= 0 {
		return results
	}

	return reachableGround(board, start, facing, mp, mode, heat)
}

// reachableGround does BFS/flood-fill for walking/running movement.
func reachableGround(board *Board, start HexCoord, startFacing int,
	totalMP int, mode MoveMode, moveHeat int) []ReachableHex {

	type state struct {
		coord  HexCoord
		mpLeft int
		hexes  int
	}

	visited := make(map[HexCoord]int) // coord -> min MP spent
	visited[start] = 0

	queue := []state{{coord: start, mpLeft: totalMP, hexes: 0}}
	var results []ReachableHex

	for len(queue) > 0 {
		cur := queue[0]
		queue = queue[1:]

		neighbors := Neighbors(cur.coord)
		for _, n := range neighbors {
			if !board.InBounds(n) {
				continue
			}

			cost := MovementCost(board, cur.coord, n, mode)
			if cost < 0 {
				continue
			}

			remaining := cur.mpLeft - cost
			if remaining < 0 {
				continue
			}

			mpSpent := totalMP - remaining
			if prev, ok := visited[n]; ok && mpSpent >= prev {
				continue
			}
			visited[n] = mpSpent

			newHexes := cur.hexes + 1
			queue = append(queue, state{coord: n, mpLeft: remaining, hexes: newHexes})
		}
	}

	// Generate results for all reachable hexes with optimal facing toward center
	for coord, mpSpent := range visited {
		if coord == start && mpSpent == 0 {
			continue // skip standing still (handled by ModeStand)
		}
		hexesMoved := mpSpent // approximate; terrain makes this >= actual hexes
		// For TMM, hexesMoved is the number of hexes entered, which equals MP spent
		// in open terrain but can be less in heavy terrain. Use MP spent as conservative estimate.

		// Try 6 facings, prefer facing toward board center or cheapest facing change
		bestFacing := bearingToFacing(coord, HexCoord{Col: board.Width / 2, Row: board.Height / 2})
		results = append(results, ReachableHex{
			Coord:      coord,
			Facing:     bestFacing,
			Mode:       mode,
			MPSpent:    mpSpent,
			HexesMoved: hexesMoved,
			MoveHeat:   moveHeat,
		})
	}

	return results
}

// reachableJump returns all hexes within jumpMP distance.
// Jumping ignores terrain, costs 1 MP per hex distance.
func reachableJump(board *Board, start HexCoord, startFacing int, jumpMP int) []ReachableHex {
	var results []ReachableHex

	// Check hexes within bounded range of jumpMP distance
	minCol := start.Col - jumpMP
	if minCol < 1 {
		minCol = 1
	}
	maxCol := start.Col + jumpMP
	if maxCol > board.Width {
		maxCol = board.Width
	}
	minRow := start.Row - jumpMP
	if minRow < 1 {
		minRow = 1
	}
	maxRow := start.Row + jumpMP
	if maxRow > board.Height {
		maxRow = board.Height
	}
	for col := minCol; col <= maxCol; col++ {
		for row := minRow; row <= maxRow; row++ {
			coord := HexCoord{Col: col, Row: row}
			dist := HexDistance(start, coord)
			if dist == 0 || dist > jumpMP {
				continue
			}
			hex := board.Get(coord)
			if hex == nil {
				continue
			}

			// Jump heat: max(3, hexes jumped)
			jumpHeat := dist
			if jumpHeat < 3 {
				jumpHeat = 3
			}

			// Can choose any facing when landing
			// Use facing toward board center as default, actual facing chosen by AI
			bestFacing := bearingToFacing(coord, HexCoord{Col: board.Width / 2, Row: board.Height / 2})

			results = append(results, ReachableHex{
				Coord:      coord,
				Facing:     bestFacing,
				Mode:       ModeJump,
				MPSpent:    dist,
				HexesMoved: dist,
				MoveHeat:   jumpHeat,
			})
		}
	}

	return results
}
